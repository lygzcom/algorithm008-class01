# 栈和队列

## 栈

> - 栈 (stack) 是限定仅在表尾进行插入或删除操作的线性表。
> - 因此， 对栈来说， 表尾端有其特殊含义，称为栈顶 (top), 相应地， 表头端称为栈底 (bottom)。
>   不含元素的空表称为空栈。
> - 栈又称为后进先出 (Last In First Out, LIFO) 的线性表。
> - 栈就像洗碗叠盘子一样的操作

## 栈的应用

- 浏览器前进后退
- 表达式计算（难点）
- 括号匹配检测
- 汉诺塔问题
- 迷宫求解问题
- 进制转换
- 逆序输出

## 队列(queue)

> - 队列是一种先进先出(First In First Out，FIFO)的线性表。
> - 它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进入队列的元素最早离开。不含元素的空表称为空队列。
> - 在队列中，允许插入的一端称为队尾(rear), 允许 删除的一端则称为队头(front)。

## 队列的应用

- 排队系统

- LRU cache

## 栈的基本操作

|       操作       |    初始条件     |                  操作结果                   |
| :--------------: | :-------------: | :-----------------------------------------: |
|   InitStack(S)   |       无        |                构造一个空栈S                |
| DeStroyStack(S)  |    栈S已存在    |                  栈S被销毁                  |
|  ClearStack(S)   |    栈S已存在    |                 将S清为空栈                 |
|  StackEmpty(S)   |    栈S已存在    | 若栈 S 为空栈， 则返回 true, 否则返回 false |
|  StackLength(S)  |    栈S已存在    |        返回S的元素个数， 即栈的长度         |
|    GetTop(S)     | 栈S已存在且非空 |      返回S的栈顶元素， 不修改栈顶指针       |
|    PuSh(S,e)     |    栈S已存在    |           插入元素e为新的栈顶元素           |
|     Pop(S,e)     | 栈S已存在且非空 |       删除S的栈顶元素，并用e返回其值        |
| StackTraverSe(S) | 栈S已存在且非空 |  从栈底到栈顶依次对S的每个数据元素进行访问  |

## 栈的两种实现

- 顺序存储结构实现

> 需要设置栈顶、栈底指针，数组末尾作为栈顶方便添加删除，判空条件栈顶指针==栈底指针；
>
> 缺点存储空间需要提前设定，动态扩容有一定代价；

- 链式存储结构实现

> 需要设置、栈底指针，链表不需要头指针，表头就是栈顶，链表为空==栈空

### 利用栈将递归转为非递归

## 队列的基本操作
|       操作       |    初始条件     |                  操作结果                   |
| :--------------: | :-------------: | :---------------------------------------: |
|   InitQueue(Q)   |       无        |                构造一个空队列Q                |
| DeQtroyQueue(Q)  |    队列Q已存在    |                  队列Q被销毁                  |
|  ClearQueue(Q)   |    队列Q已存在    |                 将Q清为空队列                 |
|  QueueEmpty(Q)   |    队列Q已存在    | 若队列 Q 为空队列， 则返回 true, 否则返回 false |
|  QueueLength(Q)  |    队列Q已存在    |        返回Q的元素个数， 即队列的长度         |
|    GetHeadp(Q)   | 队列Q已存在且非空 |      返回Q的队头元素       |
|    EnQueue(Q,e)    |    队列Q已存在    |           插入元素e为新的队尾元素           |
|     DeQueue(Q,e)     | 队列Q已存在且非空 |       删除Q的队头元素，并用e返回其值        |
| QueueTraverQe(Q) | 队列Q已存在且非空 |  从队头到队尾依次对Q的每个数据元素进行访问  |







